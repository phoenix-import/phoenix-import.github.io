<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EUDR GeoJSON Converter</title>
    
    <!-- MapLibre GL JS -->
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    
    <!-- MapLibre GL Draw -->
    <link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.0/mapbox-gl-draw.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.0/mapbox-gl-draw.js"></script>
    
    <!-- Proj4js for UTM conversion -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.min.js"></script>
    
    <!-- Turf.js for geometry operations -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
        }
        
        .input-modes {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .mode-btn {
            padding: 10px 20px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .mode-btn.active {
            background: #2c3e50;
            color: white;
            border-color: #2c3e50;
        }
        
        .main-content {
            display: flex;
            gap: 20px;
        }
        
        .input-panel {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .map-container {
            flex: 1;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 600px;
        }
        
        .input-mode {
            display: none;
        }
        
        .input-mode.active {
            display: block;
        }
        
        .coord-grid {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .coord-grid th, .coord-grid td {
            padding: 8px;
            border: 1px solid #ddd;
            text-align: left;
        }
        
        .coord-grid th {
            background: #f8f8f8;
        }
        
        .coord-grid input {
            width: 100%;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        
        .metadata-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }
        
        .metadata-note {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .btn {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-top: 10px;
        }
        
        .btn:hover {
            background: #2980b9;
        }
        
        .btn.danger {
            background: #e74c3c;
        }
        
        .btn.danger:hover {
            background: #c0392b;
        }
        
        .btn.success {
            background: #27ae60;
        }
        
        .btn.success:hover {
            background: #229954;
        }
        
        .validation-result {
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            display: none;
        }
        
        .validation-result.error {
            background: #fee;
            border: 1px solid #fcc;
            color: #c00;
        }
        
        .validation-result.success {
            background: #efe;
            border: 1px solid #cfc;
            color: #060;
        }
        
        .stats-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1;
            min-width: 200px;
        }
        
        .stat-row {
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .stat-label {
            font-weight: 500;
        }
        
        .warning {
            color: #f39c12;
            font-weight: bold;
        }
        
        .error {
            color: #e74c3c;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>EUDR GeoJSON Converter</h1>
        <p class="subtitle">Convert supplier geodata to EUDR-compliant GeoJSON format</p>
        
        <div class="input-modes">
            <button class="mode-btn active" data-mode="utm">UTM Entry</button>
            <button class="mode-btn" data-mode="wgs84">WGS84 Entry</button>
            <button class="mode-btn" data-mode="map">Map Selection</button>
        </div>
        
        <div class="main-content">
            <div class="input-panel">
                <!-- UTM Entry Mode -->
                <div class="input-mode active" id="utm-mode">
                    <h3>UTM Coordinate Entry</h3>
                    <p>Enter UTM coordinates. They will be converted to WGS84 (EPSG:4326)</p>
                    
                    <div class="form-group">
                        <label>UTM Zone (1-60)</label>
                        <input type="number" id="utm-zone" min="1" max="60" value="33">
                    </div>
                    
                    <div class="form-group">
                        <label>Hemisphere</label>
                        <select id="utm-hemisphere">
                            <option value="N">Northern</option>
                            <option value="S">Southern</option>
                        </select>
                    </div>
                    
                    <table class="coord-grid">
                        <thead>
                            <tr>
                                <th>Point #</th>
                                <th>Easting (m)</th>
                                <th>Northing (m)</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="utm-coords">
                            <tr>
                                <td>1</td>
                                <td><input type="number" class="utm-easting" step="0.01"></td>
                                <td><input type="number" class="utm-northing" step="0.01"></td>
                                <td><button class="btn danger" onclick="removeRow(this)">×</button></td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <button class="btn" onclick="addUTMRow()">Add Point</button>
                    <button class="btn" onclick="closeRing('utm')">Close Ring</button>
                    <button class="btn success" onclick="processUTM()">Convert & Preview</button>
                </div>
                
                <!-- WGS84 Entry Mode -->
                <div class="input-mode" id="wgs84-mode">
                    <h3>WGS84 Coordinate Entry</h3>
                    <p>Enter decimal degree coordinates [longitude, latitude]</p>
                    
                    <table class="coord-grid">
                        <thead>
                            <tr>
                                <th>Point #</th>
                                <th>Longitude</th>
                                <th>Latitude</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="wgs84-coords">
                            <tr>
                                <td>1</td>
                                <td><input type="number" class="wgs84-lon" step="0.000001" min="-180" max="180"></td>
                                <td><input type="number" class="wgs84-lat" step="0.000001" min="-90" max="90"></td>
                                <td><button class="btn danger" onclick="removeRow(this)">×</button></td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <button class="btn" onclick="addWGS84Row()">Add Point</button>
                    <button class="btn" onclick="closeRing('wgs84')">Close Ring</button>
                    <button class="btn success" onclick="processWGS84()">Preview on Map</button>
                </div>
                
                <!-- Map Selection Mode -->
                <div class="input-mode" id="map-mode">
                    <h3>Map Selection</h3>
                    <p>Draw polygons directly on the map</p>
                    
                    <div style="margin-bottom: 15px;">
                        Use the polygon tool in the top-left corner of the map to draw
                        Click to add vertices
                        Double-click to finish polygon
                        Click on a polygon to edit vertices
                    </div>
                    
                    <button class="btn danger" onclick="clearDrawings()">Clear All</button>
                    <button class="btn" onclick="simplifyDrawings()">Simplify Polygons</button>
                </div>
                
                <!-- Metadata Section (shown for all modes) -->
                <div class="metadata-section">
                    <h3>Optional Supplier Metadata</h3>
                    <p class="metadata-note">Used by the EU IS to group producers; entirely optional but recommended.</p>
                    
                    <div class="form-group">
                        <label>Producer Name</label>
                        <input type="text" id="producer-name" placeholder="e.g., Forest Products Ltd">
                    </div>
                    
                    <div class="form-group">
                        <label>Producer Country (ISO-2)</label>
                        <input type="text" id="producer-country" placeholder="e.g., BR" maxlength="2" style="text-transform: uppercase;">
                    </div>
                    
                    <div class="form-group">
                        <label>Production Place</label>
                        <input type="text" id="production-place" placeholder="e.g., Amazon Region">
                    </div>
                </div>
                
                <!-- Validation and Export -->
                <div class="validation-result" id="validation-result"></div>
                
                <div style="margin-top: 20px;">
                    <button class="btn" onclick="validateGeoJSON()">Validate</button>
                    <button class="btn success" onclick="exportGeoJSON()" id="export-btn" disabled>Export GeoJSON</button>
                </div>
            </div>
            
            <div class="map-container">
                <div id="map"></div>
                <div class="stats-panel">
                    <div class="stat-row">
                        <span class="stat-label">Features:</span> <span id="feature-count">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Vertices:</span> <span id="vertex-count">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Area:</span> <span id="total-area">0 ha</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">File Size (est):</span> <span id="file-size">0 KB</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Initialize map
        let map;
        let draw;
        let currentMode = 'utm';
        let currentFeatures = [];
        let isValid = false;
        
        // Initialize MapLibre GL map
        map = new maplibregl.Map({
            container: 'map',
            style: {
                version: 8,
                sources: {
                    osm: {
                        type: 'raster',
                        tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                        tileSize: 256,
                        attribution: '© OpenStreetMap contributors'
                    }
                },
                layers: [{
                    id: 'osm',
                    type: 'raster',
                    source: 'osm'
                }]
            },
            center: [0, 0],
            zoom: 2
        });
        
        // Initialize drawing controls with custom styles
        draw = new MapboxDraw({
            displayControlsDefault: false,
            controls: {
                polygon: true,
                trash: true
            },
            
        
        // Listen to draw events
        map.on('draw.create', updateStats);
        map.on('draw.delete', updateStats);
        map.on('draw.update', updateStats);
        
        // Mode switching
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.input-mode').forEach(m => m.classList.remove('active'));
                
                this.classList.add('active');
                currentMode = this.dataset.mode;
                document.getElementById(currentMode + '-mode').classList.add('active');
                
                // Show/hide draw controls based on mode
                if (currentMode === 'map') {
                    document.querySelector('.mapboxgl-ctrl-group').style.display = 'block';
                } else {
                    document.querySelector('.mapboxgl-ctrl-group').style.display = 'none';
                }
            });
        });
        
        // Hide draw controls initially
        document.querySelector('.mapboxgl-ctrl-group').style.display = 'none';
        
        // UTM Functions
        function addUTMRow() {
            const tbody = document.getElementById('utm-coords');
            const rowCount = tbody.children.length + 1;
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${rowCount}</td>
                <td><input type="number" class="utm-easting" step="0.01"></td>
                <td><input type="number" class="utm-northing" step="0.01"></td>
                <td><button class="btn danger" onclick="removeRow(this)">×</button></td>
            `;
            tbody.appendChild(row);
        }
        
        function processUTM() {
            const zone = parseInt(document.getElementById('utm-zone').value);
            const hemisphere = document.getElementById('utm-hemisphere').value;
            
            if (!zone || zone < 1 || zone > 60) {
                showValidation('UTM zone must be between 1 and 60', 'error');
                return;
            }
            
            const coords = [];
            const rows = document.querySelectorAll('#utm-coords tr');
            
            rows.forEach(row => {
                const easting = parseFloat(row.querySelector('.utm-easting').value);
                const northing = parseFloat(row.querySelector('.utm-northing').value);
                
                if (!isNaN(easting) && !isNaN(northing)) {
                    // Define UTM projection
                    const projString = `+proj=utm +zone=${zone} ${hemisphere === 'S' ? '+south' : ''} +datum=WGS84`;
                    const wgs84 = proj4(projString, 'WGS84', [easting, northing]);
                    coords.push(roundCoordinate(wgs84));
                }
            });
            
            if (coords.length < 3) {
                showValidation('Need at least 3 points to create a polygon', 'error');
                return;
            }
            
            // Ensure ring is closed
            if (coords[0][0] !== coords[coords.length - 1][0] || 
                coords[0][1] !== coords[coords.length - 1][1]) {
                coords.push([...coords[0]]);
            }
            
            displayPolygon([coords]);
        }
        
        // WGS84 Functions
        function addWGS84Row() {
            const tbody = document.getElementById('wgs84-coords');
            const rowCount = tbody.children.length + 1;
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${rowCount}</td>
                <td><input type="number" class="wgs84-lon" step="0.000001" min="-180" max="180"></td>
                <td><input type="number" class="wgs84-lat" step="0.000001" min="-90" max="90"></td>
                <td><button class="btn danger" onclick="removeRow(this)">×</button></td>
            `;
            tbody.appendChild(row);
        }
        
        function processWGS84() {
            const coords = [];
            const rows = document.querySelectorAll('#wgs84-coords tr');
            
            rows.forEach(row => {
                const lon = parseFloat(row.querySelector('.wgs84-lon').value);
                const lat = parseFloat(row.querySelector('.wgs84-lat').value);
                
                if (!isNaN(lon) && !isNaN(lat)) {
                    if (lat < -90 || lat > 90) {
                        showValidation('Latitude must be between -90 and 90', 'error');
                        return;
                    }
                    if (lon < -180 || lon > 180) {
                        showValidation('Longitude must be between -180 and 180', 'error');
                        return;
                    }
                    coords.push(roundCoordinate([lon, lat]));
                }
            });
            
            if (coords.length < 3) {
                showValidation('Need at least 3 points to create a polygon', 'error');
                return;
            }
            
            // Ensure ring is closed
            if (coords[0][0] !== coords[coords.length - 1][0] || 
                coords[0][1] !== coords[coords.length - 1][1]) {
                coords.push([...coords[0]]);
            }
            
            displayPolygon([coords]);
        }
        
        // Common Functions
        function removeRow(btn) {
            btn.closest('tr').remove();
            // Renumber rows
            const tbody = btn.closest('tbody');
            const rows = tbody.querySelectorAll('tr');
            rows.forEach((row, index) => {
                row.querySelector('td:first-child').textContent = index + 1;
            });
        }
        
        function closeRing(mode) {
            let tbody, eastingClass, northingClass, lonClass, latClass;
            
            if (mode === 'utm') {
                tbody = document.getElementById('utm-coords');
                const rows = tbody.querySelectorAll('tr');
                if (rows.length < 3) {
                    showValidation('Need at least 3 points before closing ring', 'error');
                    return;
                }
                
                const firstEasting = rows[0].querySelector('.utm-easting').value;
                const firstNorthing = rows[0].querySelector('.utm-northing').value;
                
                if (firstEasting && firstNorthing) {
                    addUTMRow();
                    const lastRow = tbody.lastElementChild;
                    lastRow.querySelector('.utm-easting').value = firstEasting;
                    lastRow.querySelector('.utm-northing').value = firstNorthing;
                }
            } else if (mode === 'wgs84') {
                tbody = document.getElementById('wgs84-coords');
                const rows = tbody.querySelectorAll('tr');
                if (rows.length < 3) {
                    showValidation('Need at least 3 points before closing ring', 'error');
                    return;
                }
                
                const firstLon = rows[0].querySelector('.wgs84-lon').value;
                const firstLat = rows[0].querySelector('.wgs84-lat').value;
                
                if (firstLon && firstLat) {
                    addWGS84Row();
                    const lastRow = tbody.lastElementChild;
                    lastRow.querySelector('.wgs84-lon').value = firstLon;
                    lastRow.querySelector('.wgs84-lat').value = firstLat;
                }
            }
        }
        
        function roundCoordinate(coord) {
            return [
                Math.round(coord[0] * 1000000) / 1000000,
                Math.round(coord[1] * 1000000) / 1000000
            ];
        }
        
        function displayPolygon(coordinates) {
            // Clear existing features
            draw.deleteAll();
            
            // Create polygon feature
            const polygon = turf.polygon(coordinates);
            
            // Add to map
            draw.add(polygon);
            
            // Fit map to bounds
            const bbox = turf.bbox(polygon);
            map.fitBounds(bbox, { padding: 50 });
            
            updateStats();
        }
        
        function clearDrawings() {
            draw.deleteAll();
            updateStats();
        }
        
        function simplifyDrawings() {
            const features = draw.getAll();
            if (features.features.length === 0) {
                showValidation('No polygons to simplify', 'error');
                return;
            }
            
            draw.deleteAll();
            
            features.features.forEach(feature => {
                if (feature.geometry.type === 'Polygon') {
                    // Simplify using Turf
                    const simplified = turf.simplify(feature, {
                        tolerance: 0.00001,
                        highQuality: true
                    });
                    draw.add(simplified);
                }
            });
            
            updateStats();
            showValidation('Polygons simplified', 'success');
        }
        
        function updateStats() {
            const features = draw.getAll();
            let totalVertices = 0;
            let totalArea = 0;
            
            features.features.forEach(feature => {
                if (feature.geometry.type === 'Polygon') {
                    totalVertices += feature.geometry.coordinates[0].length;
                    const area = turf.area(feature);
                    totalArea += area / 10000; // Convert to hectares
                }
            });
            
            document.getElementById('feature-count').textContent = features.features.length;
            document.getElementById('vertex-count').textContent = totalVertices;
            document.getElementById('total-area').textContent = totalArea.toFixed(2) + ' ha';
            
            // Estimate file size
            const jsonStr = JSON.stringify(features);
            const bytes = new TextEncoder().encode(jsonStr).length;
            const kb = bytes / 1024;
            const mb = kb / 1024;
            
            let sizeText = kb < 1000 ? kb.toFixed(2) + ' KB' : mb.toFixed(2) + ' MB';
            
            if (mb > 10) {
                sizeText = `<span class="error">${sizeText} (exceeds 10MB limit)</span>`;
            } else if (mb > 5) {
                sizeText = `<span class="warning">${sizeText} (approaching limit)</span>`;
            }
            
            document.getElementById('file-size').innerHTML = sizeText;
            
            currentFeatures = features.features;
        }
        
        function validateGeoJSON() {
            const features = draw.getAll();
            
            if (features.features.length === 0) {
                showValidation('No features to validate', 'error');
                return;
            }
            
            let errors = [];
            
            features.features.forEach((feature, index) => {
                // Check if polygon
                if (feature.geometry.type !== 'Polygon' && feature.geometry.type !== 'MultiPolygon') {
                    errors.push(`Feature ${index + 1}: Must be Polygon or MultiPolygon`);
                }
                
                // Check vertices count
                if (feature.geometry.type === 'Polygon') {
                    const vertices = feature.geometry.coordinates[0].length;
                    if (vertices > 1000) {
                        errors.push(`Feature ${index + 1}: Too many vertices (${vertices}/1000 max)`);
                    }
                    if (vertices < 4) {
                        errors.push(`Feature ${index + 1}: Too few vertices (minimum 4)`);
                    }
                    
                    // Check if closed
                    const first = feature.geometry.coordinates[0][0];
                    const last = feature.geometry.coordinates[0][feature.geometry.coordinates[0].length - 1];
                    if (first[0] !== last[0] || first[1] !== last[1]) {
                        errors.push(`Feature ${index + 1}: Ring is not closed`);
                    }
                    
                    // Check for self-intersection
                    const kinks = turf.kinks(feature);
                    if (kinks.features.length > 0) {
                        errors.push(`Feature ${index + 1}: Contains self-intersections`);
                    }
                }
            });
            
            // Check total features count
            if (features.features.length > 200) {
                errors.push(`Too many features (${features.features.length}/200 max)`);
            }
            
            // Check file size
            const jsonStr = JSON.stringify(features);
            const mb = new TextEncoder().encode(jsonStr).length / (1024 * 1024);
            if (mb > 10) {
                errors.push(`File size exceeds 10MB limit (${mb.toFixed(2)}MB)`);
            }
            
            if (errors.length === 0) {
                showValidation('Validation successful! Ready to export.', 'success');
                isValid = true;
                document.getElementById('export-btn').disabled = false;
            } else {
                showValidation(errors.join('\n'), 'error');
                isValid = false;
                document.getElementById('export-btn').disabled = true;
            }
        }
        
        function showValidation(message, type) {
            const result = document.getElementById('validation-result');
            result.textContent = message;
            result.className = 'validation-result ' + type;
            result.style.display = 'block';
        }
        
        function exportGeoJSON() {
            if (!isValid) {
                validateGeoJSON();
                if (!isValid) return;
            }
            
            const features = draw.getAll();
            
            // Add metadata if provided
            const producerName = document.getElementById('producer-name').value;
            const producerCountry = document.getElementById('producer-country').value;
            const productionPlace = document.getElementById('production-place').value;
            
            features.features.forEach(feature => {
                feature.properties = feature.properties || {};
                
                if (producerName) feature.properties.ProducerName = producerName;
                if (producerCountry) feature.properties.ProducerCountry = producerCountry.toUpperCase();
                if (productionPlace) feature.properties.ProductionPlace = productionPlace;
                
                // Calculate area for each feature
                const area = turf.area(feature) / 10000; // hectares
                feature.properties.Area = Math.round(area * 100) / 100;
            });
            
            // Round all coordinates to 6 decimal places
            features.features.forEach(feature => {
                if (feature.geometry.type === 'Polygon') {
                    feature.geometry.coordinates[0] = feature.geometry.coordinates[0].map(coord => 
                        roundCoordinate(coord)
                    );
                }
            });
            
            // Add CRS explicitly
            features.crs = {
                type: "name",
                properties: {
                    name: "urn:ogc:def:crs:OGC:1.3:CRS84"
                }
            };
            
            // Create download
            const dataStr = JSON.stringify(features, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
            
            const exportName = 'eudr_geojson_' + new Date().toISOString().slice(0, 10) + '.geojson';
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportName);
            linkElement.click();
            
            showValidation('GeoJSON exported successfully!', 'success');
        }
    </script>
</body>
</html>
