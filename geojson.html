<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EUDR GeoJSON Converter</title>
    
    <!-- Leaflet CSS and JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Leaflet Draw -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    
    <!-- Proj4js for UTM conversion -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4leaflet/1.0.2/proj4leaflet.min.js"></script>
    
    <!-- Turf.js for geometry operations -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
        }
        
        .input-modes {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .mode-btn {
            padding: 10px 20px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .mode-btn.active {
            background: #2c3e50;
            color: white;
            border-color: #2c3e50;
        }
        
        .main-content {
            display: flex;
            gap: 20px;
        }
        
        .input-panel {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 500px;
        }
        
        .map-container {
            flex: 1.5;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 600px;
        }
        
        .input-mode {
            display: none;
        }
        
        .input-mode.active {
            display: block;
        }
        
        .coord-grid {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .coord-grid th, .coord-grid td {
            padding: 8px;
            border: 1px solid #ddd;
            text-align: left;
        }
        
        .coord-grid th {
            background: #f8f8f8;
            font-weight: 500;
        }
        
        .coord-grid input {
            width: 100%;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        
        .metadata-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }
        
        .metadata-note {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            font-style: italic;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .btn {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-top: 10px;
            font-size: 14px;
        }
        
        .btn:hover {
            background: #2980b9;
        }
        
        .btn.danger {
            background: #e74c3c;
        }
        
        .btn.danger:hover {
            background: #c0392b;
        }
        
        .btn.success {
            background: #27ae60;
        }
        
        .btn.success:hover {
            background: #229954;
        }
        
        .btn.small {
            padding: 4px 8px;
            margin: 0;
            font-size: 12px;
        }
        
        .validation-result {
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            display: none;
            white-space: pre-line;
        }
        
        .validation-result.error {
            background: #fee;
            border: 1px solid #fcc;
            color: #c00;
        }
        
        .validation-result.success {
            background: #efe;
            border: 1px solid #cfc;
            color: #060;
        }
        
        .validation-result.warning {
            background: #fef8e7;
            border: 1px solid #fdeaa8;
            color: #856404;
        }
        
        .stats-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1000;
            min-width: 200px;
        }
        
        .stat-row {
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .stat-label {
            font-weight: 500;
            display: inline-block;
            min-width: 100px;
        }
        
        .stat-value {
            color: #2c3e50;
        }
        
        .warning {
            color: #f39c12;
            font-weight: bold;
        }
        
        .error {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .map-instructions {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .map-instructions ul {
            margin-left: 20px;
            margin-top: 10px;
        }
        
        .leaflet-draw-toolbar {
            margin-top: 10px !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>EUDR GeoJSON Converter</h1>
        <p class="subtitle">Convert supplier geodata to EUDR-compliant GeoJSON format</p>
        
        <div class="input-modes">
            <button class="mode-btn active" data-mode="wgs84">WGS84 Entry</button>
            <button class="mode-btn" data-mode="utm">UTM Entry</button>
            <button class="mode-btn" data-mode="map">Map Selection</button>
        </div>
        
        <div class="main-content">
            <div class="input-panel">
                <!-- WGS84 Entry Mode -->
                <div class="input-mode active" id="wgs84-mode">
                    <h3>WGS84 Coordinate Entry</h3>
                    <p>Enter decimal degree coordinates [longitude, latitude]</p>
                    
                    <table class="coord-grid">
                        <thead>
                            <tr>
                                <th>Point</th>
                                <th>Longitude</th>
                                <th>Latitude</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="wgs84-coords">
                            <tr>
                                <td>1</td>
                                <td><input type="number" class="wgs84-lon" step="0.000001" min="-180" max="180"></td>
                                <td><input type="number" class="wgs84-lat" step="0.000001" min="-90" max="90"></td>
                                <td><button class="btn danger small" onclick="removeRow(this)">Ã—</button></td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <button class="btn" onclick="addWGS84Row()">Add Point</button>
                    <button class="btn" onclick="closeRing('wgs84')">Close Ring</button>
                    <button class="btn success" onclick="processWGS84()">Preview on Map</button>
                </div>
                
                <!-- UTM Entry Mode -->
                <div class="input-mode" id="utm-mode">
                    <h3>UTM Coordinate Entry</h3>
                    <p>Enter UTM coordinates. They will be converted to WGS84 (EPSG:4326)</p>
                    
                    <div class="form-group">
                        <label>UTM Zone (1-60)</label>
                        <input type="number" id="utm-zone" min="1" max="60" value="33">
                    </div>
                    
                    <div class="form-group">
                        <label>Hemisphere</label>
                        <select id="utm-hemisphere">
                            <option value="N">Northern</option>
                            <option value="S">Southern</option>
                        </select>
                    </div>
                    
                    <table class="coord-grid">
                        <thead>
                            <tr>
                                <th>Point</th>
                                <th>Easting (m)</th>
                                <th>Northing (m)</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="utm-coords">
                            <tr>
                                <td>1</td>
                                <td><input type="number" class="utm-easting" step="0.01"></td>
                                <td><input type="number" class="utm-northing" step="0.01"></td>
                                <td><button class="btn danger small" onclick="removeRow(this)">Ã—</button></td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <button class="btn" onclick="addUTMRow()">Add Point</button>
                    <button class="btn" onclick="closeRing('utm')">Close Ring</button>
                    <button class="btn success" onclick="processUTM()">Convert & Preview</button>
                </div>
                
                <!-- Map Selection Mode -->
                <div class="input-mode" id="map-mode">
                    <h3>Map Selection</h3>
                    <div class="map-instructions">
                        <strong>Drawing instructions:</strong>
                        <ul>
                            <li>Click the polygon tool (â–¡) on the map</li>
                            <li>Click to place vertices on the map</li>
                            <li>Click the first point again to close the polygon</li>
                            <li>Click on existing polygons to edit them</li>
                            <li>Use the trash icon to delete selected polygons</li>
                        </ul>
                    </div>
                    
                    <button class="btn danger" onclick="clearAllPolygons()">Clear All Polygons</button>
                    <button class="btn" onclick="simplifyPolygons()">Simplify Polygons</button>
                    <button class="btn success" onclick="captureFromMap()">Capture Current Polygons</button>
                </div>
                
                <!-- Metadata Section (shown for all modes) -->
                <div class="metadata-section">
                    <h3>Optional Supplier Metadata</h3>
                    <p class="metadata-note">Used by the EU IS to group producers; entirely optional but recommended.</p>
                    
                    <div class="form-group">
                        <label>Producer Name</label>
                        <input type="text" id="producer-name" placeholder="e.g., Forest Products Ltd">
                    </div>
                    
                    <div class="form-group">
                        <label>Producer Country (ISO-2)</label>
                        <input type="text" id="producer-country" placeholder="e.g., BR" maxlength="2" style="text-transform: uppercase;">
                    </div>
                    
                    <div class="form-group">
                        <label>Production Place</label>
                        <input type="text" id="production-place" placeholder="e.g., Amazon Region">
                    </div>
                </div>
                
                <!-- Validation and Export -->
                <div class="validation-result" id="validation-result"></div>
                
                <div style="margin-top: 20px;">
                    <button class="btn" onclick="validateGeoJSON()">Validate</button>
                    <button class="btn success" onclick="exportGeoJSON()" id="export-btn" disabled>Export GeoJSON</button>
                </div>
            </div>
            
            <div class="map-container">
                <div id="map"></div>
                <div class="stats-panel">
                    <div class="stat-row">
                        <span class="stat-label">Features:</span> 
                        <span class="stat-value" id="feature-count">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Vertices:</span> 
                        <span class="stat-value" id="vertex-count">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Area:</span> 
                        <span class="stat-value" id="total-area">0 ha</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">File Size:</span> 
                        <span class="stat-value" id="file-size">0 KB</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let map;
        let drawnItems;
        let drawControl;
        let currentMode = 'wgs84';
        let currentFeatures = [];
        let isValid = false;
        
        // Initialize Leaflet map
        function initMap() {
            map = L.map('map').setView([0, 0], 2);
            
            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);
            
            // Initialize the FeatureGroup to store editable layers
            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);
            
            // Initialize the draw control
            drawControl = new L.Control.Draw({
                position: 'topleft',
                draw: {
                    polygon: {
                        allowIntersection: false,
                        showArea: true,
                        shapeOptions: {
                            color: '#2c3e50',
                            fillColor: '#3498db',
                            fillOpacity: 0.3,
                            weight: 2
                        }
                    },
                    polyline: false,
                    circle: false,
                    circlemarker: false,
                    rectangle: false,
                    marker: false
                },
                edit: {
                    featureGroup: drawnItems,
                    edit: true,
                    remove: true
                }
            });
            
            // Event handlers for drawing
            map.on(L.Draw.Event.CREATED, function(e) {
                const layer = e.layer;
                drawnItems.addLayer(layer);
                updateStats();
            });
            
            map.on(L.Draw.Event.EDITED, function(e) {
                updateStats();
            });
            
            map.on(L.Draw.Event.DELETED, function(e) {
                updateStats();
            });
        }
        
        // Initialize the map on page load
        window.onload = function() {
            initMap();
        };
        
        // Mode switching
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.input-mode').forEach(m => m.classList.remove('active'));
                
                this.classList.add('active');
                currentMode = this.dataset.mode;
                document.getElementById(currentMode + '-mode').classList.add('active');
                
                // Show/hide draw controls based on mode
                if (currentMode === 'map') {
                    map.addControl(drawControl);
                } else {
                    map.removeControl(drawControl);
                }
            });
        });
        
        // WGS84 Functions
        function addWGS84Row() {
            const tbody = document.getElementById('wgs84-coords');
            const rowCount = tbody.children.length + 1;
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${rowCount}</td>
                <td><input type="number" class="wgs84-lon" step="0.000001" min="-180" max="180"></td>
                <td><input type="number" class="wgs84-lat" step="0.000001" min="-90" max="90"></td>
                <td><button class="btn danger small" onclick="removeRow(this)">Ã—</button></td>
            `;
            tbody.appendChild(row);
        }
        
        function processWGS84() {
            const coords = [];
            const rows = document.querySelectorAll('#wgs84-coords tr');
            
            let hasError = false;
            rows.forEach(row => {
                const lon = parseFloat(row.querySelector('.wgs84-lon').value);
                const lat = parseFloat(row.querySelector('.wgs84-lat').value);
                
                if (!isNaN(lon) && !isNaN(lat)) {
                    if (lat < -90 || lat > 90) {
                        showValidation('Latitude must be between -90 and 90', 'error');
                        hasError = true;
                        return;
                    }
                    if (lon < -180 || lon > 180) {
                        showValidation('Longitude must be between -180 and 180', 'error');
                        hasError = true;
                        return;
                    }
                    coords.push([lat, lon]); // Leaflet uses [lat, lon]
                }
            });
            
            if (hasError) return;
            
            if (coords.length < 3) {
                showValidation('Need at least 3 points to create a polygon', 'error');
                return;
            }
            
            // Ensure ring is closed
            if (coords[0][0] !== coords[coords.length - 1][0] || 
                coords[0][1] !== coords[coords.length - 1][1]) {
                coords.push([...coords[0]]);
            }
            
            displayPolygon(coords);
            showValidation('Polygon added to map', 'success');
        }
        
        // UTM Functions
        function addUTMRow() {
            const tbody = document.getElementById('utm-coords');
            const rowCount = tbody.children.length + 1;
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${rowCount}</td>
                <td><input type="number" class="utm-easting" step="0.01"></td>
                <td><input type="number" class="utm-northing" step="0.01"></td>
                <td><button class="btn danger small" onclick="removeRow(this)">Ã—</button></td>
            `;
            tbody.appendChild(row);
        }
        
        function processUTM() {
            const zone = parseInt(document.getElementById('utm-zone').value);
            const hemisphere = document.getElementById('utm-hemisphere').value;
            
            if (!zone || zone < 1 || zone > 60) {
                showValidation('UTM zone must be between 1 and 60', 'error');
                return;
            }
            
            const coords = [];
            const rows = document.querySelectorAll('#utm-coords tr');
            
            rows.forEach(row => {
                const easting = parseFloat(row.querySelector('.utm-easting').value);
                const northing = parseFloat(row.querySelector('.utm-northing').value);
                
                if (!isNaN(easting) && !isNaN(northing)) {
                    // Define UTM projection
                    const projString = `+proj=utm +zone=${zone} ${hemisphere === 'S' ? '+south' : ''} +datum=WGS84`;
                    const wgs84 = proj4(projString, 'WGS84', [easting, northing]);
                    coords.push([wgs84[1], wgs84[0]]); // Leaflet uses [lat, lon]
                }
            });
            
            if (coords.length < 3) {
                showValidation('Need at least 3 points to create a polygon', 'error');
                return;
            }
            
            // Ensure ring is closed
            if (coords[0][0] !== coords[coords.length - 1][0] || 
                coords[0][1] !== coords[coords.length - 1][1]) {
                coords.push([...coords[0]]);
            }
            
            displayPolygon(coords);
            showValidation('UTM coordinates converted and polygon added to map', 'success');
        }
        
        // Common Functions
        function removeRow(btn) {
            btn.closest('tr').remove();
            // Renumber rows
            const tbody = btn.closest('tbody');
            const rows = tbody.querySelectorAll('tr');
            rows.forEach((row, index) => {
                row.querySelector('td:first-child').textContent = index + 1;
            });
        }
        
        function closeRing(mode) {
            if (mode === 'utm') {
                const tbody = document.getElementById('utm-coords');
                const rows = tbody.querySelectorAll('tr');
                if (rows.length < 3) {
                    showValidation('Need at least 3 points before closing ring', 'error');
                    return;
                }
                
                const firstEasting = rows[0].querySelector('.utm-easting').value;
                const firstNorthing = rows[0].querySelector('.utm-northing').value;
                
                if (firstEasting && firstNorthing) {
                    addUTMRow();
                    const lastRow = tbody.lastElementChild;
                    lastRow.querySelector('.utm-easting').value = firstEasting;
                    lastRow.querySelector('.utm-northing').value = firstNorthing;
                }
            } else if (mode === 'wgs84') {
                const tbody = document.getElementById('wgs84-coords');
                const rows = tbody.querySelectorAll('tr');
                if (rows.length < 3) {
                    showValidation('Need at least 3 points before closing ring', 'error');
                    return;
                }
                
                const firstLon = rows[0].querySelector('.wgs84-lon').value;
                const firstLat = rows[0].querySelector('.wgs84-lat').value;
                
                if (firstLon && firstLat) {
                    addWGS84Row();
                    const lastRow = tbody.lastElementChild;
                    lastRow.querySelector('.wgs84-lon').value = firstLon;
                    lastRow.querySelector('.wgs84-lat').value = firstLat;
                }
            }
        }
        
        function displayPolygon(coordinates) {
            // Create and add polygon to map
            const polygon = L.polygon(coordinates, {
                color: '#2c3e50',
                fillColor: '#3498db',
                fillOpacity: 0.3,
                weight: 2
            });
            
            drawnItems.addLayer(polygon);
            
            // Fit map to bounds
            const bounds = polygon.getBounds();
            map.fitBounds(bounds, { padding: [50, 50] });
            
            updateStats();
        }
        
        // Map mode functions
        function clearAllPolygons() {
            drawnItems.clearLayers();
            updateStats();
            showValidation('All polygons cleared', 'warning');
        }
        
        function simplifyPolygons() {
            const layers = [];
            drawnItems.eachLayer(function(layer) {
                if (layer instanceof L.Polygon) {
                    const latlngs = layer.getLatLngs()[0];
                    const coords = latlngs.map(ll => [ll.lng, ll.lat]);
                    
                    // Create GeoJSON and simplify
                    const polygon = turf.polygon([coords]);
                    const simplified = turf.simplify(polygon, {
                        tolerance: 0.00001,
                        highQuality: true
                    });
                    
                    // Convert back to Leaflet format
                    const simplifiedCoords = simplified.geometry.coordinates[0].map(c => [c[1], c[0]]);
                    layers.push(simplifiedCoords);
                }
            });
            
            // Clear and redraw
            drawnItems.clearLayers();
            layers.forEach(coords => {
                const polygon = L.polygon(coords, {
                    color: '#2c3e50',
                    fillColor: '#3498db',
                    fillOpacity: 0.3,
                    weight: 2
                });
                drawnItems.addLayer(polygon);
            });
            
            updateStats();
            showValidation('Polygons simplified', 'success');
        }
        
        function captureFromMap() {
            updateStats();
            if (currentFeatures.length === 0) {
                showValidation('No polygons drawn on map', 'error');
                return;
            }
            showValidation(`Captured ${currentFeatures.length} polygon(s) from map`, 'success');
        }
        
        function updateStats() {
            const features = [];
            let totalVertices = 0;
            let totalArea = 0;
            
            drawnItems.eachLayer(function(layer) {
                if (layer instanceof L.Polygon) {
                    const latlngs = layer.getLatLngs()[0];
                    const coords = latlngs.map(ll => [ll.lng, ll.lat]);
                    
                    // Ensure closed ring
                    if (coords[0][0] !== coords[coords.length - 1][0] || 
                        coords[0][1] !== coords[coords.length - 1][1]) {
                        coords.push([...coords[0]]);
                    }
                    
                    const feature = {
                        type: "Feature",
                        geometry: {
                            type: "Polygon",
                            coordinates: [coords]
                        },
                        properties: {}
                    };
                    
                    features.push(feature);
                    totalVertices += coords.length;
                    
                    // Calculate area
                    const area = turf.area(feature);
                    totalArea += area / 10000; // Convert to hectares
                }
            });
            
            document.getElementById('feature-count').textContent = features.length;
            document.getElementById('vertex-count').textContent = totalVertices;
            document.getElementById('total-area').textContent = totalArea.toFixed(2) + ' ha';
            
            // Estimate file size
            const featureCollection = {
                type: "FeatureCollection",
                features: features
            };
            
            const jsonStr = JSON.stringify(featureCollection);
            const bytes = new TextEncoder().encode(jsonStr).length;
            const kb = bytes / 1024;
            const mb = kb / 1024;
            
            let sizeText = kb < 1000 ? kb.toFixed(2) + ' KB' : mb.toFixed(2) + ' MB';
            
            if (mb > 10) {
                document.getElementById('file-size').innerHTML = `<span class="error">${sizeText}</span>`;
            } else if (mb > 5) {
                document.getElementById('file-size').innerHTML = `<span class="warning">${sizeText}</span>`;
            } else {
                document.getElementById('file-size').textContent = sizeText;
            }
            
            currentFeatures = features;
        }
        
        function validateGeoJSON() {
            if (currentFeatures.length === 0) {
                showValidation('No features to validate. Draw polygons on the map or enter coordinates.', 'error');
                return;
            }
            
            let errors = [];
            
            currentFeatures.forEach((feature, index) => {
                // Check vertices count
                const vertices = feature.geometry.coordinates[0].length;
                if (vertices > 1000) {
                    errors.push(`Feature ${index + 1}: Too many vertices (${vertices}/1000 max)`);
                }
                if (vertices < 4) {
                    errors.push(`Feature ${index + 1}: Too few vertices (minimum 4)`);
                }
                
                // Check if closed
                const first = feature.geometry.coordinates[0][0];
                const last = feature.geometry.coordinates[0][feature.geometry.coordinates[0].length - 1];
                if (first[0] !== last[0] || first[1] !== last[1]) {
                    errors.push(`Feature ${index + 1}: Ring is not closed`);
                }
                
                // Check for self-intersection
                try {
                    const kinks = turf.kinks(feature);
                    if (kinks.features.length > 0) {
                        errors.push(`Feature ${index + 1}: Contains self-intersections`);
                    }
                } catch (e) {
                    // Skip kinks check if it fails
                }
                
                // Check area
                const area = turf.area(feature) / 10000; // hectares
                if (area === 0) {
                    errors.push(`Feature ${index + 1}: Zero area`);
                }
            });
            
            // Check total features count
            if (currentFeatures.length > 200) {
                errors.push(`Too many features (${currentFeatures.length}/200 max)`);
            }
            
            // Check file size
            const jsonStr = JSON.stringify({ type: "FeatureCollection", features: currentFeatures });
            const mb = new TextEncoder().encode(jsonStr).length / (1024 * 1024);
            if (mb > 10) {
                errors.push(`File size exceeds 10MB limit (${mb.toFixed(2)}MB)`);
            }
            
            if (errors.length === 0) {
                showValidation('Validation successful! Ready to export.', 'success');
                isValid = true;
                document.getElementById('export-btn').disabled = false;
            } else {
                showValidation('Validation errors:\n' + errors.join('\n'), 'error');
                isValid = false;
                document.getElementById('export-btn').disabled = true;
            }
        }
        
        function showValidation(message, type) {
            const result = document.getElementById('validation-result');
            result.textContent = message;
            result.className = 'validation-result ' + type;
            result.style.display = 'block';
            
            // Auto-hide success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    result.style.display = 'none';
                }, 5000);
            }
        }
        
        function exportGeoJSON() {
            if (!isValid) {
                validateGeoJSON();
                if (!isValid) return;
            }
            
            // Add metadata if provided
            const producerName = document.getElementById('producer-name').value;
            const producerCountry = document.getElementById('producer-country').value;
            const productionPlace = document.getElementById('production-place').value;
            
            const features = currentFeatures.map(feature => {
                const newFeature = JSON.parse(JSON.stringify(feature)); // Deep clone
                
                if (producerName) newFeature.properties.ProducerName = producerName;
                if (producerCountry) newFeature.properties.ProducerCountry = producerCountry.toUpperCase();
                if (productionPlace) newFeature.properties.ProductionPlace = productionPlace;
                
                // Calculate and add area
                const area = turf.area(feature) / 10000; // hectares
                newFeature.properties.Area = Math.round(area * 100) / 100;
                
                // Round coordinates to 6 decimal places
                newFeature.geometry.coordinates[0] = newFeature.geometry.coordinates[0].map(coord => [
                    Math.round(coord[0] * 1000000) / 1000000,
                    Math.round(coord[1] * 1000000) / 1000000
                ]);
                
                return newFeature;
            });
            
            const featureCollection = {
                type: "FeatureCollection",
                features: features,
                crs: {
                    type: "name",
                    properties: {
                        name: "urn:ogc:def:crs:OGC:1.3:CRS84"
                    }
                }
            };
            
            // Create download
            const dataStr = JSON.stringify(featureCollection, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
            
            const exportName = 'eudr_geojson_' + new Date().toISOString().slice(0, 10) + '.geojson';
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportName);
            linkElement.click();
            
            showValidation('GeoJSON exported successfully!', 'success');
        }
    </script>
</body>
</html>
